Userspace LEDs
==============

The uleds driver supports userspace LEDs. This can be useful for testing
triggers and can also be used to implement virtual LEDs.


Usage
=====

When the driver is loaded, a character device is created at /dev/uleds. To
create a new LED class device, open /dev/uleds and write a uleds_user_dev
structure to it (found in kernel public header file linux/uleds.h).

    #define ULEDS_MAX_NAME_SIZE 80

    struct uleds_user_dev {
        char name[ULEDS_MAX_NAME_SIZE];
    };

A new LED class device will be created with the name given. The name can be
any valid file name, but consider using the LED class naming convention of
"devicename:color:function".

The current brightness is found by reading a single byte from the character
device. Values are unsigned: 0 to 255. Reading does not block and always returns
the most recent brightness value. The device node can also be polled to notify
when the brightness value changes.

The LED class device will be removed when the open file handle to /dev/uleds
is closed.


Example
=======

/*
 * uledmon.c
 *
 * This program creates a new userspace LED class device and monitors it. A
 * timestamp and brightness value is printed each time the brightness changes.
 *
 * Usage: uledmon <device-name>
 *
 * <device-name> is the name of the LED class device to be created. Pressing
 * CTRL+C will exit.
 */

#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <linux/uleds.h>

int main(int argc, char const *argv[])
{
    struct uleds_user_dev uleds_dev;
    int fd, ret;
    struct pollfd pfd;
    unsigned char brightness;
    struct timespec ts;

    if (argc != 2) {
        fprintf(stderr, "Requires <device-name> argument\n");
        return 1;
    }

    strncpy(uleds_dev.name, argv[1], ULEDS_MAX_NAME_SIZE);

    fd = open("/dev/uleds", O_RDWR);
    if (fd == -1) {
        perror("Failed to open /dev/uleds");
        return 1;
    }

    ret = write(fd, &uleds_dev, sizeof(uleds_dev));
    if (ret == -1) {
        perror("Failed to write to /dev/uleds");
        close(fd);
        return 1;
    }

    pfd.fd = fd;
    pfd.events = POLLIN;
    pfd.revents = 0;

    while (!(pfd.revents & (POLLERR | POLLHUP | POLLNVAL))) {
        ret = read(fd, &brightness, 1);
        if (ret == -1) {
            perror("Failed to read from /dev/uleds");
            close(fd);
            return 1;
        }
        clock_gettime(CLOCK_MONOTONIC, &ts);
        printf("[%ld.%09ld] %u\n", ts.tv_sec, ts.tv_nsec, brightness);
        poll(&pfd, 1, -1);
    }

    close(fd);

    return 0;
}
